{"version":3,"file":"index.js","mappings":"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","sources":["webpack://npm-dts/webpack/universalModuleDefinition","webpack://npm-dts/./lib/cli.ts","webpack://npm-dts/./lib/generator.ts","webpack://npm-dts/./lib/log.ts","webpack://npm-dts/external commonjs \"args\"","webpack://npm-dts/external commonjs \"mkdirp\"","webpack://npm-dts/external commonjs \"npm-run\"","webpack://npm-dts/external commonjs \"rimraf\"","webpack://npm-dts/external commonjs \"tmp\"","webpack://npm-dts/external commonjs \"winston\"","webpack://npm-dts/external node-commonjs \"fs\"","webpack://npm-dts/external node-commonjs \"path\"","webpack://npm-dts/webpack/bootstrap","webpack://npm-dts/./index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(global, () => {\nreturn ","import * as args from 'args'\r\nimport * as path from 'path'\r\nimport {ELogLevel} from './log'\r\n\r\n/**\r\n * CLI argument names\r\n */\r\nexport enum ECliArgument {\r\n  /**\r\n   * Main file of non-bundled package source\r\n   */\r\n  entry = 'entry',\r\n\r\n  /**\r\n   * Root directory of targeted package\r\n   */\r\n  root = 'root',\r\n\r\n  /**\r\n   * Temporary directory required during generation\r\n   */\r\n  tmp = 'tmp',\r\n\r\n  /**\r\n   * Additional TSC properties\r\n   */\r\n  tsc = 'tsc',\r\n\r\n  /**\r\n   * Selected logging level\r\n   */\r\n  logLevel = 'logLevel',\r\n\r\n  /**\r\n   * Output file path (relative to root)\r\n   */\r\n  output = 'output',\r\n\r\n  /**\r\n   * Flag which forces using own TSC as opposed to target TSC\r\n   * This should only be used for testing npm-dts itself\r\n   * This is because it generates incorrect module names\r\n   */\r\n  testMode = 'testMode',\r\n\r\n  /**\r\n   * Flag which forces attempting generation at least partially despite errors\r\n   */\r\n  force = 'force',\r\n}\r\n\r\n/**\r\n * Configuration structure for generating an aggregated dts file\r\n */\r\nexport interface INpmDtsArgs {\r\n  /**\r\n   * Iterator\r\n   */\r\n  [argName: string]: string | boolean\r\n\r\n  /**\r\n   * Main file of non-bundled package source. Can be a path relative to TSC rootDir.\r\n   */\r\n  entry?: string\r\n\r\n  /**\r\n   * Root directory of targeted package\r\n   */\r\n  root?: string\r\n\r\n  /**\r\n   * Temporary directory required during generation\r\n   */\r\n  tmp?: string\r\n\r\n  /**\r\n   * Additional TSC properties\r\n   */\r\n  tsc?: string\r\n\r\n  /**\r\n   * Selected logging level\r\n   */\r\n  logLevel?: ELogLevel\r\n\r\n  /**\r\n   * Attempts to at least partially generate typings ignoring non-critical errors\r\n   */\r\n  force?: boolean\r\n\r\n  /**\r\n   * Output file path (relative to root)\r\n   */\r\n  output?: string\r\n\r\n  /**\r\n   * Flag which forces using own TSC as opposed to target TSC\r\n   * This should only be used for testing npm-dts itself\r\n   * This is because it generates incorrect module names\r\n   */\r\n  testMode?: boolean\r\n}\r\n\r\n/**\r\n * CLI usage logic\r\n */\r\nexport class Cli {\r\n  /**\r\n   * Stores whether module was successfully launched\r\n   */\r\n  protected launched = false\r\n\r\n  /**\r\n   * Stores whether TMP directory location was passed\r\n   */\r\n  protected tmpPassed = false\r\n\r\n  /**\r\n   * Stores current CLI argument values\r\n   */\r\n  private args: INpmDtsArgs = {\r\n    entry: 'index.ts',\r\n    root: path.resolve(process.cwd()),\r\n    tmp: '<TEMP>',\r\n    tsc: '',\r\n    logLevel: ELogLevel.info,\r\n    force: false,\r\n    output: 'index.d.ts',\r\n    testMode: false,\r\n  }\r\n\r\n  /**\r\n   * Automatically reads CLI arguments and performs actions based on them\r\n   */\r\n  public constructor(injectedArguments?: INpmDtsArgs) {\r\n    if (injectedArguments) {\r\n      this.launched = true\r\n      this.storeArguments(injectedArguments)\r\n    } else {\r\n      args\r\n        .option(\r\n          ['e', 'entry'],\r\n          'Entry/main package file before bundling, relative to project root',\r\n        )\r\n        .option(\r\n          ['r', 'root'],\r\n          'NPM package directory containing package.json',\r\n          this.args.root,\r\n        )\r\n        .option(\r\n          ['t', 'tmp'],\r\n          'Directory for storing temporary information',\r\n          this.args.tmp,\r\n          (value: string) => {\r\n            if (!value.includes('<')) {\r\n              this.tmpPassed = true\r\n            }\r\n\r\n            return value\r\n          },\r\n        )\r\n        .option(\r\n          ['c', 'tsc'],\r\n          'Passed through non-validated additional TSC options',\r\n          this.args.tsc,\r\n        )\r\n        .option(\r\n          ['L', 'logLevel'],\r\n          'Log level (error, warn, info, verbose, debug)',\r\n          this.args.logLevel,\r\n        )\r\n        .option(\r\n          ['f', 'force'],\r\n          'Ignores non-critical errors and attempts to at least partially generate typings',\r\n          this.args.force,\r\n        )\r\n        .option(\r\n          ['o', 'output'],\r\n          'Overrides recommended output target to a custom one',\r\n          this.args.output,\r\n        )\r\n        .option(\r\n          ['m', 'testMode'],\r\n          'Configures npm-dts for self-test',\r\n          this.args.testMode,\r\n        )\r\n        .command('generate', 'Start generation', (name, sub, options) => {\r\n          this.launched = true\r\n          this.storeArguments(options)\r\n        })\r\n        .example(\r\n          'npm-dts generate',\r\n          'Generates index.d.ts file and updates package.json for CWD.',\r\n        )\r\n        .example(\r\n          'npm-dts -r /your/project/path generate',\r\n          'Performs generation on a custom path.',\r\n        )\r\n\r\n      args.parse(process.argv, {\r\n        name: 'npm-dts',\r\n        mri: {},\r\n        mainColor: 'yellow',\r\n        subColor: 'dim',\r\n      })\r\n\r\n      if (!this.launched) {\r\n        args.showHelp()\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gathers current value of a particular CLI argument\r\n   * @param arg argument name\r\n   */\r\n  protected getArgument(arg: ECliArgument) {\r\n    return this.args[arg]\r\n  }\r\n\r\n  /**\r\n   * Dynamically overrides value of stored argument\r\n   * @param arg argument name\r\n   * @param value argument value\r\n   */\r\n  protected setArgument(arg: ECliArgument, value: string | boolean) {\r\n    // @ts-ignore\r\n    this.args[arg] = value\r\n  }\r\n\r\n  /**\r\n   * Stores entered CLI arguments\r\n   * @param passedArguments arguments entered to CLI\r\n   */\r\n  private storeArguments(passedArguments: any = this.args) {\r\n    for (const argName of Object.keys(this.args)) {\r\n      this.args[argName] = Object.is(passedArguments[argName], undefined)\r\n        ? this.args[argName]\r\n        : passedArguments[argName]\r\n    }\r\n  }\r\n}\r\n","import {readdirSync, statSync, writeFileSync} from 'fs'\r\nimport {readFileSync} from 'fs'\r\nimport * as mkdir from 'mkdirp'\r\nimport * as npmRun from 'npm-run'\r\nimport {join, relative, resolve, dirname} from 'path'\r\nimport * as rm from 'rimraf'\r\nimport * as tmp from 'tmp'\r\nimport {Cli, ECliArgument, INpmDtsArgs} from './cli'\r\nimport {debug, ELogLevel, error, info, init, verbose, warn} from './log'\r\nimport * as fs from 'fs'\r\n\r\nconst MKDIR_RETRIES = 5\r\n\r\n/**\r\n * Logic for generating aggregated typings for NPM module\r\n */\r\nexport class Generator extends Cli {\r\n  private packageInfo: any\r\n  private moduleNames: string[]\r\n  private throwErrors: boolean\r\n  private cacheContentEmptied: boolean = true\r\n\r\n  /**\r\n   * Auto-launches generation based on command line arguments\r\n   * @param injectedArguments generation arguments (same as CLI)\r\n   * @param enableLog enables logging when true, null allows application to decide\r\n   * @param throwErrors makes generation throw errors when true\r\n   */\r\n  public constructor(\r\n    injectedArguments?: INpmDtsArgs,\r\n    enableLog: boolean | null = null,\r\n    throwErrors = false,\r\n  ) {\r\n    super(injectedArguments)\r\n\r\n    this.throwErrors = throwErrors\r\n\r\n    if (enableLog === null) {\r\n      enableLog = !injectedArguments\r\n    }\r\n\r\n    if (enableLog) {\r\n      init('npm-dts', this.getLogLevel())\r\n\r\n      const myPackageJson = JSON.parse(\r\n        readFileSync(resolve(__dirname, '..', 'package.json'), {\r\n          encoding: 'utf8',\r\n        }),\r\n      )\r\n\r\n      const soft = `          npm-dts v${myPackageJson.version}                `\r\n      let author = '          by Vytenis Urbonavičius                          '\r\n      let spaces = '                                                           '\r\n      let border = '___________________________________________________________'\r\n\r\n      author = author.substring(0, soft.length)\r\n      spaces = spaces.substring(0, soft.length)\r\n      border = border.substring(0, soft.length)\r\n\r\n      info(` ${border} `)\r\n      info(`|${spaces}|`)\r\n      info(`|${spaces}|`)\r\n      info(`|${soft}|`)\r\n      info(`|${author}|`)\r\n      info(`|${spaces}|`)\r\n      info(`|${border}|`)\r\n      info(` ${spaces} `)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Executes generation of an aggregated dts file\r\n   */\r\n  public async generate() {\r\n    info(`Generating declarations for \"${this.getRoot()}\"...`)\r\n\r\n    let hasError = false\r\n    let exception = null\r\n    const cleanupTasks: (() => void)[] = []\r\n\r\n    if (!this.tmpPassed) {\r\n      verbose('Locating OS Temporary Directory...')\r\n\r\n      try {\r\n        await new Promise<void>(done => {\r\n          tmp.dir((tmpErr, tmpDir, rmTmp) => {\r\n            if (tmpErr) {\r\n              error('Could not create OS Temporary Directory!')\r\n              this.showDebugError(tmpErr)\r\n              throw tmpErr\r\n            }\r\n\r\n            verbose('OS Temporary Directory was located!')\r\n            this.setArgument(ECliArgument.tmp, resolve(tmpDir, 'npm-dts'))\r\n\r\n            cleanupTasks.push(() => {\r\n              verbose('Deleting OS Temporary Directory...')\r\n              rmTmp()\r\n              verbose('OS Temporary Directory was deleted!')\r\n            })\r\n            done()\r\n          })\r\n        })\r\n      } catch (e) {\r\n        hasError = true\r\n        exception = e\r\n      }\r\n    }\r\n\r\n    if (!hasError) {\r\n      await this._generate().catch(async e => {\r\n        hasError = true\r\n\r\n        const output = this.getOutput()\r\n\r\n        error(`Generation of ${output} has failed!`)\r\n        this.showDebugError(e)\r\n\r\n        if (!this.useForce()) {\r\n          if (this.getLogLevel() === ELogLevel.debug) {\r\n            info(\r\n              'If issue is not severe, you can try forcing execution using force flag.',\r\n            )\r\n            info(\r\n              'In case of command line usage, add \"-f\" as the first parameter.',\r\n            )\r\n          } else {\r\n            info('You should try running npm-dts with debug level logging.')\r\n            info(\r\n              'In case of command line, debug mode is enabled using \"-L debug\".',\r\n            )\r\n          }\r\n        }\r\n\r\n        if (!this.cacheContentEmptied) {\r\n          await this.clearTempDir()\r\n        }\r\n\r\n        exception = e\r\n      })\r\n    }\r\n\r\n    cleanupTasks.forEach(task => task())\r\n\r\n    if (!hasError) {\r\n      info('Generation is completed!')\r\n    } else {\r\n      error('Generation failed!')\r\n\r\n      if (this.throwErrors) {\r\n        throw exception || new Error('Generation failed!')\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Logs serialized error if it exists\r\n   * @param e - error to be shown\r\n   */\r\n  private showDebugError(e: any) {\r\n    if (e) {\r\n      if (e.stdout) {\r\n        debug(`Error: \\n${e.stdout.toString()}`)\r\n      } else {\r\n        debug(`Error: \\n${JSON.stringify(e)}`)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Launches generation of typings\r\n   */\r\n  private async _generate() {\r\n    await this.generateTypings()\r\n    let source = await this.combineTypings()\r\n    source = this.addAlias(source)\r\n    await this.storeResult(source)\r\n  }\r\n\r\n  private getLogLevel(): ELogLevel {\r\n    const logLevel = this.getArgument(ECliArgument.logLevel) as ELogLevel\r\n    return ELogLevel[logLevel] ? logLevel : ELogLevel.info\r\n  }\r\n\r\n  /**\r\n   * Gathers entry file address (relative to project root path)\r\n   */\r\n  private getEntry(): string {\r\n    return this.getArgument(ECliArgument.entry) as string\r\n  }\r\n\r\n  /**\r\n   * Gathers target project root path\r\n   */\r\n  private getRoot(): string {\r\n    return resolve(this.getArgument(ECliArgument.root) as string)\r\n  }\r\n\r\n  /**\r\n   * Gathers TMP directory to be used for TSC operations\r\n   */\r\n  private getTempDir(): string {\r\n    return resolve(this.getArgument(ECliArgument.tmp) as string)\r\n  }\r\n\r\n  /**\r\n   * Gathers output path to be used (relative to root)\r\n   */\r\n  private getOutput(): string {\r\n    return this.getArgument(ECliArgument.output) as string\r\n  }\r\n\r\n  /**\r\n   * Checks if script is forced to use its built-in TSC\r\n   */\r\n  private useTestMode(): boolean {\r\n    return this.getArgument(ECliArgument.testMode) as boolean\r\n  }\r\n\r\n  /**\r\n   * Checks if script is forced to attempt generation despite errors\r\n   */\r\n  private useForce(): boolean {\r\n    return this.getArgument(ECliArgument.force) as boolean\r\n  }\r\n\r\n  /**\r\n   * Creates TMP directory to be used for TSC operations\r\n   * @param retries amount of times to retry on failure\r\n   */\r\n  private makeTempDir(retries = MKDIR_RETRIES): Promise<void> {\r\n    const tmpDir = this.getTempDir()\r\n    verbose('Preparing \"tmp\" directory...')\r\n\r\n    return new Promise((done, fail) => {\r\n      mkdir(tmpDir)\r\n        .then(() => {\r\n          this.cacheContentEmptied = false\r\n          verbose('\"tmp\" directory was prepared!')\r\n          done()\r\n        })\r\n        .catch(mkdirError => {\r\n          error(`Failed to create \"${tmpDir}\"!`)\r\n          this.showDebugError(mkdirError)\r\n\r\n          if (retries) {\r\n            const sleepTime = 100\r\n            verbose(`Will retry in ${sleepTime}ms...`)\r\n\r\n            setTimeout(() => {\r\n              this.makeTempDir(retries - 1).then(done, fail)\r\n            }, sleepTime)\r\n          } else {\r\n            error(`Stopped trying after ${MKDIR_RETRIES} retries!`)\r\n            fail()\r\n          }\r\n        })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Removes TMP directory\r\n   */\r\n  private clearTempDir() {\r\n    const tmpDir = this.getTempDir()\r\n    verbose('Cleaning up \"tmp\" directory...')\r\n\r\n    return new Promise<void>((done, fail) => {\r\n      rm(tmpDir, rmError => {\r\n        if (rmError) {\r\n          error(`Could not clean up \"tmp\" directory at \"${tmpDir}\"!`)\r\n          this.showDebugError(rmError)\r\n          fail()\r\n        } else {\r\n          this.cacheContentEmptied = true\r\n          verbose('\"tmp\" directory was cleaned!')\r\n          done()\r\n        }\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Re-creates empty TMP directory to be used for TSC operations\r\n   */\r\n  private resetCacheDir() {\r\n    verbose('Will now reset \"tmp\" directory...')\r\n    return new Promise((done, fail) => {\r\n      this.clearTempDir().then(() => {\r\n        this.makeTempDir().then(done, fail)\r\n      }, fail)\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Generates per-file typings using TSC\r\n   */\r\n  private async generateTypings() {\r\n    await this.resetCacheDir()\r\n\r\n    verbose('Generating per-file typings using TSC...')\r\n\r\n    const tscOptions = this.getArgument(ECliArgument.tsc) as string\r\n\r\n    const cmd =\r\n      'tsc --declaration --emitDeclarationOnly --declarationDir \"' +\r\n      this.getTempDir() +\r\n      '\"' +\r\n      (tscOptions.length ? ` ${tscOptions}` : '')\r\n\r\n    debug(cmd)\r\n\r\n    try {\r\n      npmRun.execSync(\r\n        cmd,\r\n        {\r\n          cwd: this.useTestMode() ? resolve(__dirname, '..') : this.getRoot(),\r\n        },\r\n        (err: any, stdout: any, stderr: any) => {\r\n          if (err) {\r\n            if (this.useForce()) {\r\n              warn('TSC exited with errors!')\r\n            } else {\r\n              error('TSC exited with errors!')\r\n            }\r\n\r\n            this.showDebugError(err)\r\n          } else {\r\n            if (stdout) {\r\n              process.stdout.write(stdout)\r\n            }\r\n\r\n            if (stderr) {\r\n              process.stderr.write(stderr)\r\n            }\r\n          }\r\n        },\r\n      )\r\n    } catch (e) {\r\n      if (this.useForce()) {\r\n        warn('Suppressing errors due to \"force\" flag!')\r\n        this.showDebugError(e)\r\n        warn('Generated declaration files might not be valid!')\r\n      } else {\r\n        throw e\r\n      }\r\n    }\r\n\r\n    verbose('Per-file typings have been generated using TSC!')\r\n  }\r\n\r\n  /**\r\n   * Gathers a list of created per-file declaration files\r\n   * @param dir directory to be scanned for files (called during recursion)\r\n   * @param files discovered array of files (called during recursion)\r\n   */\r\n  private getDeclarationFiles(\r\n    dir: string = this.getTempDir(),\r\n    files: string[] = [],\r\n  ) {\r\n    if (dir === this.getTempDir()) {\r\n      verbose('Loading list of generated typing files...')\r\n    }\r\n\r\n    try {\r\n      readdirSync(dir).forEach(file => {\r\n        if (statSync(join(dir, file)).isDirectory()) {\r\n          files = this.getDeclarationFiles(join(dir, file), files)\r\n        } else {\r\n          files = files.concat(join(dir, file))\r\n        }\r\n      })\r\n    } catch (e) {\r\n      error('Failed to load list of generated typing files...')\r\n      this.showDebugError(e)\r\n      throw e\r\n    }\r\n\r\n    if (dir === this.getTempDir()) {\r\n      verbose('Successfully loaded list of generated typing files!')\r\n    }\r\n\r\n    return files\r\n  }\r\n\r\n  /**\r\n   * Loads package.json information of target project\r\n   */\r\n  private getPackageDetails() {\r\n    if (this.packageInfo) {\r\n      return this.packageInfo\r\n    }\r\n\r\n    verbose('Loading package.json...')\r\n\r\n    const root = this.getRoot()\r\n    const packageJsonPath = resolve(root, 'package.json')\r\n\r\n    try {\r\n      this.packageInfo = JSON.parse(\r\n        readFileSync(packageJsonPath, {encoding: 'utf8'}),\r\n      )\r\n    } catch (e) {\r\n      error(`Failed to read package.json at \"'${packageJsonPath}'\"`)\r\n      this.showDebugError(e)\r\n      throw e\r\n    }\r\n\r\n    verbose('package.json information has been loaded!')\r\n    return this.packageInfo\r\n  }\r\n\r\n  /**\r\n   * Generates module name based on file path\r\n   * @param path path to be converted to module name\r\n   * @param options additional conversion options\r\n   */\r\n  private convertPathToModule(\r\n    path: string,\r\n    options: IConvertPathToModuleOptions = {},\r\n  ) {\r\n    const {\r\n      rootType = IBasePathType.tmp,\r\n      noPrefix = false,\r\n      noExtensionRemoval = false,\r\n      noExistenceCheck = false,\r\n    } = options\r\n\r\n    const packageDetails = this.getPackageDetails()\r\n\r\n    const fileExisted =\r\n      noExistenceCheck ||\r\n      (!noExtensionRemoval &&\r\n        fs.existsSync(path) &&\r\n        fs.lstatSync(path).isFile())\r\n\r\n    if (rootType === IBasePathType.cwd) {\r\n      path = relative(process.cwd(), path)\r\n    } else if (rootType === IBasePathType.root) {\r\n      path = relative(this.getRoot(), path)\r\n    } else if (rootType === IBasePathType.tmp) {\r\n      path = relative(this.getTempDir(), path)\r\n    }\r\n\r\n    if (!noPrefix) {\r\n      path = `${packageDetails.name}/${path}`\r\n    }\r\n\r\n    path = path.replace(/\\\\/g, '/')\r\n\r\n    if (fileExisted && !noExtensionRemoval) {\r\n      path = path.replace(/\\.[^.]+$/g, '')\r\n      path = path.replace(/\\.d$/g, '')\r\n    }\r\n\r\n    return path\r\n  }\r\n\r\n  /**\r\n   * Loads generated per-file declaration files\r\n   */\r\n  private loadTypings() {\r\n    const result: IDeclarationMap = {}\r\n\r\n    const declarationFiles = this.getDeclarationFiles()\r\n\r\n    verbose('Loading declaration files and mapping to modules...')\r\n    declarationFiles.forEach(file => {\r\n      const moduleName = this.convertPathToModule(file)\r\n\r\n      try {\r\n        result[moduleName] = readFileSync(file, {encoding: 'utf8'})\r\n      } catch (e) {\r\n        error(`Could not load declaration file '${file}'!`)\r\n        this.showDebugError(e)\r\n        throw e\r\n      }\r\n    })\r\n\r\n    verbose('Loaded declaration files and mapped to modules!')\r\n    return result\r\n  }\r\n\r\n  private resolveImportSourcesAtLine(\r\n    regexp: RegExp,\r\n    line: string,\r\n    moduleName: string,\r\n  ) {\r\n    const matches = line.match(regexp)\r\n\r\n    if (matches && matches[2].startsWith('.')) {\r\n      const relativePath = `../${matches[2]}`\r\n\r\n      let resolvedModule = resolve(moduleName, relativePath)\r\n\r\n      resolvedModule = this.convertPathToModule(resolvedModule, {\r\n        rootType: IBasePathType.cwd,\r\n        noPrefix: true,\r\n        noExtensionRemoval: true,\r\n      })\r\n\r\n      if (!this.moduleExists(resolvedModule)) {\r\n        resolvedModule += '/index'\r\n      }\r\n\r\n      line = line.replace(regexp, `$1${resolvedModule}$3`)\r\n    }\r\n\r\n    return line\r\n  }\r\n\r\n  /**\r\n   * Alters import sources to avoid relative addresses and default index usage\r\n   * @param source import source to be resolved\r\n   * @param moduleName name of module containing import\r\n   */\r\n  private resolveImportSources(source: string, moduleName: string) {\r\n    source = source.replace(/\\r\\n/g, '\\n')\r\n    source = source.replace(/\\n\\r/g, '\\n')\r\n    source = source.replace(/\\r/g, '\\n')\r\n\r\n    let lines = source.split('\\n')\r\n\r\n    lines = lines.map(line => {\r\n      line = this.resolveImportSourcesAtLine(\r\n        /(from ['\"])([^'\"]+)(['\"])/,\r\n        line,\r\n        moduleName,\r\n      )\r\n\r\n      line = this.resolveImportSourcesAtLine(\r\n        /(import\\(['\"])([^'\"]+)(['\"]\\))/,\r\n        line,\r\n        moduleName,\r\n      )\r\n\r\n      return line\r\n    })\r\n\r\n    source = lines.join('\\n')\r\n\r\n    return source\r\n  }\r\n\r\n  /**\r\n   * Combines typings into a single declaration source\r\n   */\r\n  private async combineTypings() {\r\n    const typings = this.loadTypings()\r\n    await this.clearTempDir()\r\n\r\n    this.moduleNames = Object.keys(typings)\r\n\r\n    verbose('Combining typings into single file...')\r\n\r\n    const sourceParts: string[] = []\r\n\r\n    Object.entries(typings).forEach(([moduleName, fileSource]) => {\r\n      fileSource = fileSource.replace(/declare /g, '')\r\n      fileSource = this.resolveImportSources(fileSource, moduleName)\r\n      sourceParts.push(\r\n        `declare module '${moduleName}' {\\n${(fileSource as string).replace(\r\n          /^./gm,\r\n          '  $&',\r\n        )}\\n}`,\r\n      )\r\n    })\r\n\r\n    verbose('Combined typings into a single file!')\r\n    return sourceParts.join('\\n')\r\n  }\r\n\r\n  /**\r\n   * Verifies if module specified exists among known modules\r\n   * @param moduleName name of module to be checked\r\n   */\r\n  private moduleExists(moduleName: string) {\r\n    return this.moduleNames.includes(moduleName)\r\n  }\r\n\r\n  /**\r\n   * Adds alias for main NPM package file to generated .d.ts source\r\n   * @param source generated .d.ts declaration source so far\r\n   */\r\n  private addAlias(source: string) {\r\n    verbose('Adding alias for main file of the package...')\r\n\r\n    const packageDetails = this.getPackageDetails()\r\n    const entry = this.getEntry()\r\n\r\n    if (!entry) {\r\n      error('No entry file is available!')\r\n      throw new Error('No entry file is available!')\r\n    }\r\n\r\n    const mainFile = this.convertPathToModule(resolve(this.getRoot(), entry), {\r\n      rootType: IBasePathType.root,\r\n      noExistenceCheck: true,\r\n    })\r\n\r\n    source +=\r\n      `\\ndeclare module '${packageDetails.name}' {\\n` +\r\n      `  import main = require('${mainFile}');\\n` +\r\n      '  export = main;\\n' +\r\n      '}'\r\n\r\n    verbose('Successfully created alias for main file!')\r\n\r\n    return source\r\n  }\r\n\r\n  /**\r\n   * Stores generated .d.ts declaration source into file\r\n   * @param source generated .d.ts source\r\n   */\r\n  private async storeResult(source: string) {\r\n    const output = this.getOutput()\r\n    const root = this.getRoot()\r\n    const file = resolve(root, output)\r\n    const folderPath = dirname(file)\r\n\r\n    verbose('Ensuring that output folder exists...')\r\n    debug(`Creating output folder: \"${folderPath}\"...`)\r\n\r\n    try {\r\n      await mkdir(folderPath)\r\n    } catch (mkdirError) {\r\n      error(`Failed to create \"${folderPath}\"!`)\r\n      this.showDebugError(mkdirError)\r\n      throw mkdirError\r\n    }\r\n\r\n    verbose('Output folder is ready!')\r\n    verbose(`Storing typings into ${output} file...`)\r\n\r\n    try {\r\n      writeFileSync(file, source, {encoding: 'utf8'})\r\n    } catch (e) {\r\n      error(`Failed to create ${output}!`)\r\n      this.showDebugError(e)\r\n      throw e\r\n    }\r\n\r\n    verbose(`Successfully created ${output} file!`)\r\n  }\r\n}\r\n\r\n/**\r\n * Map of modules and their declarations\r\n */\r\nexport interface IDeclarationMap {\r\n  [moduleNames: string]: string\r\n}\r\n\r\n/**\r\n * Types of base path used during path resolving\r\n */\r\nexport enum IBasePathType {\r\n  /**\r\n   * Base path is root of targeted project\r\n   */\r\n  root = 'root',\r\n\r\n  /**\r\n   * Base path is tmp directory\r\n   */\r\n  tmp = 'tmp',\r\n\r\n  /**\r\n   * Base path is CWD\r\n   */\r\n  cwd = 'cwd',\r\n}\r\n\r\n/**\r\n * Additional conversion options\r\n */\r\nexport interface IConvertPathToModuleOptions {\r\n  /**\r\n   * Type of base path used during path resolving\r\n   */\r\n  rootType?: IBasePathType\r\n\r\n  /**\r\n   * Disables addition of module name as prefix for module name\r\n   */\r\n  noPrefix?: boolean\r\n\r\n  /**\r\n   * Disables extension removal\r\n   */\r\n  noExtensionRemoval?: boolean\r\n\r\n  /**\r\n   * Disables existence check and assumes that file exists\r\n   */\r\n  noExistenceCheck?: boolean\r\n}\r\n","import * as winston from 'winston'\r\nimport {\r\n  debug as winstonDebug,\r\n  error as winstonError,\r\n  info as winstonInfo,\r\n  silly as winstonSilly,\r\n  verbose as winstonVerbose,\r\n  warn as winstonWarn,\r\n} from 'winston'\r\n\r\nwinston.addColors({\r\n  error: 'red',\r\n  warn: 'yellow',\r\n  info: 'cyan',\r\n  debug: 'green',\r\n})\r\n\r\nlet logEnabled = false\r\n\r\n/**\r\n * Supported debug levels\r\n */\r\nexport enum ELogLevel {\r\n  /**\r\n   * Error\r\n   */\r\n  error = 'error',\r\n\r\n  /**\r\n   * Warning\r\n   */\r\n  warn = 'warn',\r\n\r\n  /**\r\n   * Information\r\n   */\r\n  info = 'info',\r\n\r\n  /**\r\n   * Verbose information\r\n   */\r\n  verbose = 'verbose',\r\n\r\n  /**\r\n   * Debug information\r\n   */\r\n  debug = 'debug',\r\n}\r\n\r\n/**\r\n * Logs error message\r\n * @param message Message to be logged\r\n */\r\nexport const error = (message: string) => {\r\n  if (logEnabled) {\r\n    return winstonError(message)\r\n  } else {\r\n    return null\r\n  }\r\n}\r\n\r\n/**\r\n * Logs warning message\r\n * @param message Message to be logged\r\n */\r\nexport const warn = (message: string) => {\r\n  if (logEnabled) {\r\n    return winstonWarn(message)\r\n  } else {\r\n    return null\r\n  }\r\n}\r\n\r\n/**\r\n * Logs informational message\r\n * @param message Message to be logged\r\n */\r\nexport const info = (message: string) => {\r\n  if (logEnabled) {\r\n    return winstonInfo(message)\r\n  } else {\r\n    return null\r\n  }\r\n}\r\n\r\n/**\r\n * Logs verbose message\r\n * @param message Message to be logged\r\n */\r\nexport const verbose = (message: string) => {\r\n  if (logEnabled) {\r\n    return winstonVerbose(message)\r\n  } else {\r\n    return null\r\n  }\r\n}\r\n\r\n/**\r\n * Logs debug message\r\n * @param message Message to be logged\r\n */\r\nexport const debug = (message: string) => {\r\n  if (logEnabled) {\r\n    return winstonDebug(message)\r\n  } else {\r\n    return null\r\n  }\r\n}\r\n\r\n/**\r\n * Initializes and enables logging\r\n * @param label prefix to be used before each log line\r\n */\r\nexport const init = (label: string, level: ELogLevel) => {\r\n  winston.configure({\r\n    level,\r\n    format: winston.format.combine(\r\n      winston.format.colorize(),\r\n      winston.format.label({label}),\r\n      winston.format.timestamp(),\r\n      winston.format.prettyPrint(),\r\n      winston.format.printf(\r\n        (parts: any) => `[${parts.label}] [${parts.level}] : ${parts.message}`,\r\n      ),\r\n    ),\r\n    transports: [new winston.transports.Console()],\r\n  })\r\n\r\n  logEnabled = true\r\n}\r\n","module.exports = require(\"args\");","module.exports = require(\"mkdirp\");","module.exports = require(\"npm-run\");","module.exports = require(\"rimraf\");","module.exports = require(\"tmp\");","module.exports = require(\"winston\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","export {Generator} from './lib/generator'\r\nexport {INpmDtsArgs} from './lib/cli'\r\nexport {ELogLevel} from './lib/log'\r\n"],"names":["root","factory","exports","module","define","amd","a","i","global","ECliArgument","injectedArguments","launched","tmpPassed","args","entry","path","resolve","process","cwd","tmp","tsc","logLevel","ELogLevel","info","force","output","testMode","this","storeArguments","option","value","includes","command","name","sub","options","example","parse","argv","mri","mainColor","subColor","showHelp","getArgument","arg","setArgument","passedArguments","Object","keys","argName","is","undefined","Cli","IBasePathType","enableLog","throwErrors","cacheContentEmptied","init","getLogLevel","myPackageJson","JSON","readFileSync","__dirname","encoding","soft","version","author","spaces","border","substring","length","generate","getRoot","hasError","exception","cleanupTasks","verbose","Promise","done","dir","tmpErr","tmpDir","rmTmp","error","showDebugError","push","_generate","catch","e","getOutput","useForce","debug","clearTempDir","forEach","task","Error","stdout","toString","stringify","generateTypings","combineTypings","source","addAlias","storeResult","getEntry","getTempDir","useTestMode","makeTempDir","retries","fail","mkdir","then","mkdirError","setTimeout","rm","rmError","resetCacheDir","tscOptions","cmd","npmRun","execSync","err","stderr","warn","write","getDeclarationFiles","files","readdirSync","file","statSync","join","isDirectory","concat","getPackageDetails","packageInfo","packageJsonPath","convertPathToModule","rootType","noPrefix","noExtensionRemoval","noExistenceCheck","packageDetails","fileExisted","fs","existsSync","lstatSync","isFile","relative","replace","loadTypings","result","declarationFiles","moduleName","resolveImportSourcesAtLine","regexp","line","matches","match","startsWith","relativePath","resolvedModule","moduleExists","resolveImportSources","lines","split","map","typings","moduleNames","sourceParts","entries","fileSource","mainFile","folderPath","dirname","writeFileSync","Generator","winston","addColors","logEnabled","message","label","level","configure","format","combine","colorize","timestamp","prettyPrint","printf","parts","transports","Console","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}