declare module 'npm-dts/index' {
  export { Generator } from 'npm-dts/lib/generator';
  export { INpmDtsArgs } from 'npm-dts/lib/cli';
  export { ELogLevel } from 'npm-dts/lib/log';

}
declare module 'npm-dts/lib/cli' {
  import { ELogLevel } from 'npm-dts/lib/log';
  /**
   * CLI argument names
   */
  export enum ECliArgument {
      /**
       * Main file of non-bundled package source
       */
      entry = "entry",
      /**
       * Root directory of targeted package
       */
      root = "root",
      /**
       * Temporary directory required during generation
       */
      tmp = "tmp",
      /**
       * Additional TSC properties
       */
      tsc = "tsc",
      /**
       * Selected logging level
       */
      logLevel = "logLevel",
      /**
       * Output file path (relative to root)
       */
      output = "output",
      /**
       * Flag which forces using own TSC as opposed to target TSC
       * This should only be used for testing npm-dts itself
       * This is because it generates incorrect module names
       */
      testMode = "testMode",
      /**
       * Flag which forces attempting generation at least partially despite errors
       */
      force = "force"
  }
  /**
   * Configuration structure for generating an aggregated dts file
   */
  export interface INpmDtsArgs {
      /**
       * Iterator
       */
      [argName: string]: string | boolean;
      /**
       * Main file of non-bundled package source. Can be a path relative to TSC rootDir.
       */
      entry?: string;
      /**
       * Root directory of targeted package
       */
      root?: string;
      /**
       * Temporary directory required during generation
       */
      tmp?: string;
      /**
       * Additional TSC properties
       */
      tsc?: string;
      /**
       * Selected logging level
       */
      logLevel?: ELogLevel;
      /**
       * Attempts to at least partially generate typings ignoring non-critical errors
       */
      force?: boolean;
      /**
       * Output file path (relative to root)
       */
      output?: string;
      /**
       * Flag which forces using own TSC as opposed to target TSC
       * This should only be used for testing npm-dts itself
       * This is because it generates incorrect module names
       */
      testMode?: boolean;
  }
  /**
   * CLI usage logic
   */
  export class Cli {
      /**
       * Stores whether module was successfully launched
       */
      protected launched: boolean;
      /**
       * Stores whether TMP directory location was passed
       */
      protected tmpPassed: boolean;
      /**
       * Stores current CLI argument values
       */
      private args;
      /**
       * Automatically reads CLI arguments and performs actions based on them
       */
      constructor(injectedArguments?: INpmDtsArgs);
      /**
       * Gathers current value of a particular CLI argument
       * @param arg argument name
       */
      protected getArgument(arg: ECliArgument): string | boolean;
      /**
       * Dynamically overrides value of stored argument
       * @param arg argument name
       * @param value argument value
       */
      protected setArgument(arg: ECliArgument, value: string | boolean): void;
      /**
       * Stores entered CLI arguments
       * @param passedArguments arguments entered to CLI
       */
      private storeArguments;
  }

}
declare module 'npm-dts/lib/generator' {
  import { Cli, INpmDtsArgs } from 'npm-dts/lib/cli';
  /**
   * Logic for generating aggregated typings for NPM module
   */
  export class Generator extends Cli {
      private packageInfo;
      private moduleNames;
      private throwErrors;
      private cacheContentEmptied;
      /**
       * Auto-launches generation based on command line arguments
       * @param injectedArguments generation arguments (same as CLI)
       * @param enableLog enables logging when true, null allows application to decide
       * @param throwErrors makes generation throw errors when true
       */
      constructor(injectedArguments?: INpmDtsArgs, enableLog?: boolean | null, throwErrors?: boolean);
      /**
       * Executes generation of an aggregated dts file
       */
      generate(): Promise<void>;
      /**
       * Logs serialized error if it exists
       * @param e - error to be shown
       */
      private showDebugError;
      /**
       * Launches generation of typings
       */
      private _generate;
      private getLogLevel;
      /**
       * Gathers entry file address (relative to project root path)
       */
      private getEntry;
      /**
       * Gathers target project root path
       */
      private getRoot;
      /**
       * Gathers TMP directory to be used for TSC operations
       */
      private getTempDir;
      /**
       * Gathers output path to be used (relative to root)
       */
      private getOutput;
      /**
       * Checks if script is forced to use its built-in TSC
       */
      private useTestMode;
      /**
       * Checks if script is forced to attempt generation despite errors
       */
      private useForce;
      /**
       * Creates TMP directory to be used for TSC operations
       * @param retries amount of times to retry on failure
       */
      private makeTempDir;
      /**
       * Removes TMP directory
       */
      private clearTempDir;
      /**
       * Re-creates empty TMP directory to be used for TSC operations
       */
      private resetCacheDir;
      /**
       * Generates per-file typings using TSC
       */
      private generateTypings;
      /**
       * Gathers a list of created per-file declaration files
       * @param dir directory to be scanned for files (called during recursion)
       * @param files discovered array of files (called during recursion)
       */
      private getDeclarationFiles;
      /**
       * Loads package.json information of target project
       */
      private getPackageDetails;
      /**
       * Generates module name based on file path
       * @param path path to be converted to module name
       * @param options additional conversion options
       */
      private convertPathToModule;
      /**
       * Loads generated per-file declaration files
       */
      private loadTypings;
      private resolveImportSourcesAtLine;
      /**
       * Alters import sources to avoid relative addresses and default index usage
       * @param source import source to be resolved
       * @param moduleName name of module containing import
       */
      private resolveImportSources;
      /**
       * Combines typings into a single declaration source
       */
      private combineTypings;
      /**
       * Verifies if module specified exists among known modules
       * @param moduleName name of module to be checked
       */
      private moduleExists;
      /**
       * Adds alias for main NPM package file to generated .d.ts source
       * @param source generated .d.ts declaration source so far
       */
      private addAlias;
      /**
       * Stores generated .d.ts declaration source into file
       * @param source generated .d.ts source
       */
      private storeResult;
  }
  /**
   * Map of modules and their declarations
   */
  export interface IDeclarationMap {
      [moduleNames: string]: string;
  }
  /**
   * Types of base path used during path resolving
   */
  export enum IBasePathType {
      /**
       * Base path is root of targeted project
       */
      root = "root",
      /**
       * Base path is tmp directory
       */
      tmp = "tmp",
      /**
       * Base path is CWD
       */
      cwd = "cwd"
  }
  /**
   * Additional conversion options
   */
  export interface IConvertPathToModuleOptions {
      /**
       * Type of base path used during path resolving
       */
      rootType?: IBasePathType;
      /**
       * Disables addition of module name as prefix for module name
       */
      noPrefix?: boolean;
      /**
       * Disables extension removal
       */
      noExtensionRemoval?: boolean;
      /**
       * Disables existence check and assumes that file exists
       */
      noExistenceCheck?: boolean;
  }

}
declare module 'npm-dts/lib/log' {
  import * as winston from 'winston';
  /**
   * Supported debug levels
   */
  export enum ELogLevel {
      /**
       * Error
       */
      error = "error",
      /**
       * Warning
       */
      warn = "warn",
      /**
       * Information
       */
      info = "info",
      /**
       * Verbose information
       */
      verbose = "verbose",
      /**
       * Debug information
       */
      debug = "debug"
  }
  /**
   * Logs error message
   * @param message Message to be logged
   */
  export const error: (message: string) => winston.Logger;
  /**
   * Logs warning message
   * @param message Message to be logged
   */
  export const warn: (message: string) => winston.Logger;
  /**
   * Logs informational message
   * @param message Message to be logged
   */
  export const info: (message: string) => winston.Logger;
  /**
   * Logs verbose message
   * @param message Message to be logged
   */
  export const verbose: (message: string) => winston.Logger;
  /**
   * Logs debug message
   * @param message Message to be logged
   */
  export const debug: (message: string) => winston.Logger;
  /**
   * Initializes and enables logging
   * @param label prefix to be used before each log line
   */
  export const init: (label: string, level: ELogLevel) => void;

}
declare module 'npm-dts' {
  import main = require('npm-dts/index');
  export = main;
}